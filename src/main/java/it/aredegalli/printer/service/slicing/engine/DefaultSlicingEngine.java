package it.aredegalli.printer.service.slicing.engine;

import it.aredegalli.printer.dto.storage.UploadResult;
import it.aredegalli.printer.model.model.Model;
import it.aredegalli.printer.model.resource.FileResource;
import it.aredegalli.printer.model.slicing.SlicingProperty;
import it.aredegalli.printer.model.slicing.SlicingResult;
import it.aredegalli.printer.repository.resource.FileResourceRepository;
import it.aredegalli.printer.repository.slicing.SlicingResultRepository;
import it.aredegalli.printer.service.log.LogService;
import it.aredegalli.printer.service.resource.FileResourceService;
import it.aredegalli.printer.service.storage.StorageService;
import it.aredegalli.printer.util.PrinterCostants;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigDecimal;
import java.time.Instant;

@Component
@RequiredArgsConstructor
public class DefaultSlicingEngine implements SlicingEngine {

    private final FileResourceService fileResourceService;
    private final StorageService storageService;
    private final FileResourceRepository fileResourceRepository;
    private final SlicingResultRepository slicingResultRepository;
    private final LogService logService;

    @Override
    public SlicingResult slice(Model model, SlicingProperty properties) {
        logService.info("DefaultSlicingEngine", "Starting slicing for model: " + model.getId());

        try {
            // 1. Validate model
            if (!validateModel(model)) {
                throw new RuntimeException("Model validation failed");
            }

            // 2. Get STL from existing FileResource system
            InputStream stlStream = fileResourceService.download(model.getFileResource().getId());

            // 3. Execute slicing logic
            String gcode = executeSlicing(stlStream, properties);

            // 4. Save GCODE using existing StorageService pattern
            FileResource gcodeFile = saveGCodeToStorage(gcode, model.getName() + ".gcode");

            // 5. Create SlicingResult using existing structure
            SlicingResult result = SlicingResult.builder()
                    .sourceFile(model.getFileResource())
                    .generatedFile(gcodeFile)
                    .slicingProperty(properties)
                    .lines(gcode.split("\n").length)
                    .createdAt(Instant.now())
                    .build();

            return slicingResultRepository.save(result);

        } catch (Exception e) {
            logService.error("DefaultSlicingEngine", "Slicing failed: " + e.getMessage());
            throw new RuntimeException("Slicing failed", e);
        }
    }

    @Override
    public boolean validateModel(Model model) {
        return model != null && model.getFileResource() != null;
    }

    @Override
    public String getName() {
        return "DefaultSlicer";
    }

    @Override
    public String getVersion() {
        return "1.0.0";
    }

    private String executeSlicing(InputStream stlStream, SlicingProperty properties) {
        // MVP IMPLEMENTATION - Generate basic GCODE
        StringBuilder gcode = new StringBuilder();

        // Basic GCODE header
        gcode.append("; Generated by ").append(getName()).append(" ").append(getVersion()).append("\n");
        gcode.append("G28 ; home all axes\n");
        gcode.append("G1 Z15.0 F9000 ; lift nozzle\n");

        // Temperature settings
        if (properties.getExtruderTempC() != 0) {
            gcode.append("M109 S").append(properties.getExtruderTempC()).append(" ; set and wait for hot end temp\n");
        }
        if (properties.getBedTempC() != 0) {
            gcode.append("M190 S").append(properties.getBedTempC()).append(" ; set and wait for bed temp\n");
        }

        // Simple layer logic (MVP - extend with real slicing)
        BigDecimal layerHeight = new BigDecimal(properties.getLayerHeightMm());
        int layers = 100; // Dummy - calculate from model height

        for (int layer = 0; layer < layers; layer++) {
            BigDecimal z = layerHeight.multiply(BigDecimal.valueOf(layer));
            gcode.append("; Layer ").append(layer).append("\n");
            gcode.append("G1 Z").append(z).append(" F300\n");

            // Add some movement (dummy toolpath)
            gcode.append("G1 X10 Y10 E0.1 F1500\n");
            gcode.append("G1 X50 Y10 E0.5 F1500\n");
            gcode.append("G1 X50 Y50 E0.5 F1500\n");
            gcode.append("G1 X10 Y50 E0.5 F1500\n");
            gcode.append("G1 X10 Y10 E0.5 F1500\n");
        }

        // End GCODE
        gcode.append("M104 S0 ; turn off hotend\n");
        gcode.append("M140 S0 ; turn off bed\n");
        gcode.append("G28 X0 ; home x axis\n");
        gcode.append("M84 ; disable motors\n");

        return gcode.toString();
    }

    private FileResource saveGCodeToStorage(String gcode, String filename) {
        try {
            // Use existing StorageService pattern
            UploadResult result = storageService.upload(
                    new ByteArrayInputStream(gcode.getBytes()),
                    gcode.length(),
                    "text/plain",
                    PrinterCostants.PRINTER_SLICING_STORAGE_BUCKET_NAME
            );

            return fileResourceRepository.save(FileResource.builder()
                    .fileName(filename)
                    .fileType("text/plain")
                    .fileSize(gcode.length())
                    .fileHash(result.getHashBytes())
                    .objectKey(result.getObjectKey())
                    .bucketName(PrinterCostants.PRINTER_SLICING_STORAGE_BUCKET_NAME)
                    .uploadedAt(Instant.now())
                    .build());

        } catch (Exception e) {
            throw new RuntimeException("Failed to save GCODE", e);
        }
    }
}